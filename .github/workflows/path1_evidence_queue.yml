name: Path 1 Evidence Queue Runner

on:
  workflow_dispatch:
    inputs:
      queue_path:
        description: 'Path to queue CSV file (relative to repo root)'
        required: false
        default: 'reports/path1/evidence/RUN_QUEUE.csv'
        type: string
      max_runs:
        description: 'Maximum runs to execute'
        required: false
        default: '10'
        type: string
      run_id:
        description: 'Execute only this specific run_id (leave empty for all queued)'
        required: false
        default: ''
        type: string
      commit_results:
        description: 'Commit results to new branch'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      branch_name:
        description: 'Branch name for results (auto-generated if empty)'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Dry run (validate only, no execution)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

# Required permissions for pushing branches and creating PRs
permissions:
  contents: write
  pull-requests: write

# Task C remediation: Serialize workflow runs to prevent queue race conditions
# cancel-in-progress: false ensures queue integrity (queued runs wait rather than cancel)
concurrency:
  group: path1-evidence-queue
  cancel-in-progress: false

jobs:
  run-evidence-queue:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      NEON_DSN: ${{ secrets.NEON_DSN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate inputs
        run: |
          echo "Queue path: ${{ inputs.queue_path }}"
          echo "Max runs: ${{ inputs.max_runs }}"
          echo "Run ID filter: ${{ inputs.run_id || '(all)' }}"
          echo "Commit results: ${{ inputs.commit_results }}"
          echo "Dry run: ${{ inputs.dry_run }}"
          
          # Validate queue file exists
          if [ ! -f "${{ inputs.queue_path }}" ]; then
            echo "ERROR: Queue file not found: ${{ inputs.queue_path }}"
            exit 1
          fi
          
          # Count non-empty, non-comment lines
          QUEUE_COUNT=$(grep -v '^#' "${{ inputs.queue_path }}" | grep -v '^run_id' | grep -v '^$' | wc -l)
          echo "Runs in queue: $QUEUE_COUNT"
          
          if [ "$QUEUE_COUNT" -eq 0 ]; then
            echo "WARNING: Queue is empty"
          fi

      - name: Validate required secrets
        run: |
          python3 - << 'PY'
          import os, sys
          
          db_url = os.environ.get("DATABASE_URL") or os.environ.get("NEON_DSN")
          if not db_url:
              print("ERROR: DATABASE_URL or NEON_DSN secret not configured")
              sys.exit(1)
          
          # Mask the secret
          print("Database secret: configured ✓")
          PY

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          psql --version

      - name: Determine branch name
        id: branch
        run: |
          if [ -n "${{ inputs.branch_name }}" ]; then
            BRANCH="${{ inputs.branch_name }}"
          else
            TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
            BRANCH="evidence-run-${TIMESTAMP}"
          fi
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "Branch for results: $BRANCH"

      - name: Execute evidence queue runner
        id: runner
        run: |
          # Build command
          CMD="python scripts/path1/run_evidence_queue.py"
          CMD="$CMD --queue '${{ inputs.queue_path }}'"
          CMD="$CMD --max-runs ${{ inputs.max_runs }}"
          CMD="$CMD --repo-root ."
          
          if [ -n "${{ inputs.run_id }}" ]; then
            CMD="$CMD --run-id '${{ inputs.run_id }}'"
          fi
          
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            CMD="$CMD --dry-run"
          fi
          
          echo "Executing: $CMD"
          eval $CMD | tee /tmp/runner_output.txt
          
          # Extract executed run_ids from output for validation step
          # Format: "✅ PASS | run_id | message" or "❌ FAIL | run_id | message"
          EXECUTED_RUNS=$(grep -E '^\s*(✅|❌)' /tmp/runner_output.txt | awk -F'|' '{print $2}' | tr -d ' ' | tr '\n' ',' | sed 's/,$//')
          echo "executed_runs=$EXECUTED_RUNS" >> $GITHUB_OUTPUT
          echo "Executed run IDs: $EXECUTED_RUNS"

      # NOTE:
      # Evidence artifacts are written directly to:
      #   reports/path1/evidence/runs/<run_id>/
      # following the canonical pattern established in Runs 001–003.
      # No post-processing, relocation, or archiving occurs here.

      - name: Validate Evidence Run (Post-Run Gate)
        if: inputs.dry_run != 'true'
        run: |
          echo "=== Post-Run Validation ==="
          
          # FUTURE (NOT IMPLEMENTED):
          # A queue archival / status protocol may be added later.
          # This workflow intentionally does NOT:
          # - mark queue rows as complete
          # - move completed runs
          # - archive run folders
          # The queue remains intent-only; INDEX.md is the execution ledger.
          
          # Determine which run_ids to validate
          if [ -n "${{ inputs.run_id }}" ]; then
            # Canonical pattern: specific run_id was requested
            RUNS_TO_VALIDATE="${{ inputs.run_id }}"
          else
            # Extract from runner output
            RUNS_TO_VALIDATE="${{ steps.runner.outputs.executed_runs }}"
          fi
          
          if [ -z "$RUNS_TO_VALIDATE" ]; then
            echo "No runs executed (NOOP case). Skipping validation."
            exit 0
          fi
          
          echo "Run IDs to validate: $RUNS_TO_VALIDATE"
          
          # Validate each executed run
          VALIDATION_FAILED=0
          IFS=',' read -ra RUN_ARRAY <<< "$RUNS_TO_VALIDATE"
          for RUN_ID in "${RUN_ARRAY[@]}"; do
            if [ -z "$RUN_ID" ]; then
              continue
            fi
            
            echo ""
            echo "--- Validating: $RUN_ID ---"
            
            if ! python scripts/path1/validate_post_run.py --run-id "$RUN_ID" --repo-root .; then
              echo "❌ VALIDATION FAILED: $RUN_ID"
              VALIDATION_FAILED=1
            else
              echo "✅ VALIDATION PASSED: $RUN_ID"
            fi
          done
          
          if [ "$VALIDATION_FAILED" -eq 1 ]; then
            echo ""
            echo "=========================================="
            echo "POST-RUN VALIDATION FAILED"
            echo "One or more runs did not pass integrity checks."
            echo "Review violations above. Workflow will not proceed."
            echo "=========================================="
            exit 1
          fi
          
          echo ""
          echo "✅ All evidence runs passed validation"

      - name: List generated artifacts
        if: inputs.dry_run != 'true'
        run: |
          echo "=== SQL Files Generated ==="
          find sql/path1/evidence/runs -name "*.sql" -type f 2>/dev/null | head -50 || echo "No SQL files"
          
          echo ""
          echo "=== Report Files Generated ==="
          find reports/path1/evidence/runs -name "*.md" -type f 2>/dev/null | head -50 || echo "No report files"
          
          echo ""
          echo "=== Output Files Generated ==="
          find reports/path1/evidence/runs -name "*.txt" -type f 2>/dev/null | head -50 || echo "No output files"

      # Task B remediation: Verify artifacts exist before upload
      - name: Verify artifacts exist
        if: inputs.dry_run != 'true'
        run: |
          echo "=== Artifact Verification (Task B) ==="
          
          # Count files in each artifact path
          SQL_COUNT=$(find sql/path1/evidence/runs -type f 2>/dev/null | wc -l)
          REPORT_COUNT=$(find reports/path1/evidence/runs -type f 2>/dev/null | wc -l)
          
          echo "SQL files found: $SQL_COUNT"
          echo "Report files found: $REPORT_COUNT"
          
          TOTAL=$((SQL_COUNT + REPORT_COUNT))
          echo "Total artifact files: $TOTAL"
          
          if [ "$TOTAL" -eq 0 ]; then
            echo ""
            echo "ERROR: No artifact files found!"
            echo "Expected files in:"
            echo "  - sql/path1/evidence/runs/"
            echo "  - reports/path1/evidence/runs/"
            echo ""
            echo "This indicates the evidence run did not generate expected outputs."
            echo "Check the execution logs above for errors."
            exit 1
          fi
          
          echo ""
          echo "✅ Artifact verification passed ($TOTAL files found)"

      - name: Upload artifacts
        if: inputs.dry_run != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: evidence-run-artifacts-${{ github.run_number }}
          path: |
            sql/path1/evidence/runs/
            reports/path1/evidence/runs/
            reports/path1/evidence/INDEX.md
          retention-days: 90
          # Task B remediation: Fail if no files match (explicit over default 'warn')
          if-no-files-found: error

      - name: Configure Git
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch and commit results
        id: commit
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true'
        run: |
          BRANCH="${{ steps.branch.outputs.branch }}"
          
          # Create new branch
          git checkout -b "$BRANCH"
          
          # Generate RUN_QUEUE_RESOLVED.csv (reconciles queue intent with INDEX.md ledger)
          echo "Generating RUN_QUEUE_RESOLVED.csv..."
          python scripts/path1/generate_queue_resolved.py --repo-root .
          
          # Stage generated files
          # IMPORTANT: RUN_QUEUE.csv is intentionally NOT committed.
          # Queue status updates are LOCAL ONLY and will be lost after workflow.
          # INDEX.md is the canonical execution ledger, not the queue.
          # RUN_QUEUE_RESOLVED.csv is a generated reconciliation view.
          git add sql/path1/evidence/runs/
          git add reports/path1/evidence/runs/
          git add reports/path1/evidence/INDEX.md
          git add reports/path1/evidence/RUN_QUEUE_RESOLVED.csv
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit (NOOP)"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          
          # Commit
          git commit -m "Path 1 Evidence Run(s) - Automated
          
          Queue: ${{ inputs.queue_path }}
          Max runs: ${{ inputs.max_runs }}
          Run ID filter: ${{ inputs.run_id || '(all)' }}
          
          Generated by: .github/workflows/path1_evidence_queue.yml
          Workflow run: ${{ github.run_id }}"
          
          # Push branch
          git push origin "$BRANCH"
          
          echo ""
          echo "=========================================="
          echo "Results committed to branch: $BRANCH"
          echo "=========================================="

      - name: Create Pull Request and enable auto-merge
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true' && steps.commit.outputs.has_changes == 'true'
        env:
          # Use PAT for PR creation to enable auto-merge and trigger downstream workflows
          # GITHUB_TOKEN cannot trigger workflows or enable auto-merge on PRs it creates
          # Set both to remove any ambiguity in gh CLI auth resolution
          GH_TOKEN: ${{ secrets.OVC_PR_BOT_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.OVC_PR_BOT_TOKEN }}
        run: |
          # Validate PAT secret is configured
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "=========================================="
            echo "ERROR: OVC_PR_BOT_TOKEN secret is not configured"
            echo "=========================================="
            echo ""
            echo "This workflow requires a Personal Access Token (PAT) to create PRs"
            echo "and enable auto-merge."
            echo ""
            echo "To fix: Create repo secret OVC_PR_BOT_TOKEN"
            echo "   Settings → Secrets and variables → Actions → New repository secret"
            echo ""
            exit 1
          fi
          
          # Auth probe: verify token can authenticate and access this repo
          echo "Verifying GH CLI authentication..."
          AUTH_OK=true
          
          if ! gh auth status 2>&1 | head -5; then
            echo "gh auth status failed"
            AUTH_OK=false
          fi
          
          AUTH_USER=$(gh api user -q .login 2>/dev/null || echo "")
          if [ -z "$AUTH_USER" ]; then
            echo "gh api user failed - cannot determine authenticated user"
            AUTH_OK=false
          else
            echo "Authenticated as: $AUTH_USER"
          fi
          
          REPO_CHECK=$(gh api "repos/${GITHUB_REPOSITORY}" -q .full_name 2>/dev/null || echo "")
          if [ -z "$REPO_CHECK" ]; then
            echo "gh api repos/${GITHUB_REPOSITORY} failed - cannot access repo"
            AUTH_OK=false
          else
            echo "Repo access confirmed: $REPO_CHECK"
          fi
          
          if [ "$AUTH_OK" = "false" ]; then
            echo ""
            echo "=========================================="
            echo "ERROR: OVC_PR_BOT_TOKEN cannot authenticate or cannot access this repo."
            echo "=========================================="
            echo "Regenerate token with repo access to ovc-infra and permissions:"
            echo "  - Pull requests: Read and Write"
            echo "  - Contents: Read and Write"
            echo "=========================================="
            exit 1
          fi
          
          echo "Auth probe passed."
          echo ""
          
          BRANCH="${{ steps.branch.outputs.branch }}"
          
          # Check if PR already exists for this branch
          EXISTING_PR=$(gh pr list --head "$BRANCH" --json number,url --jq '.[0]' 2>/dev/null || echo "")
          
          if [ -n "$EXISTING_PR" ] && [ "$EXISTING_PR" != "null" ]; then
            PR_NUMBER=$(echo "$EXISTING_PR" | jq -r '.number')
            PR_URL=$(echo "$EXISTING_PR" | jq -r '.url')
            echo "PR #$PR_NUMBER already exists for branch $BRANCH"
          else
            # Create PR
            echo "Creating Pull Request..."
            PR_URL=$(gh pr create \
              --base main \
              --head "$BRANCH" \
              --title "Path 1 Evidence Run(s) - $(date -u +%Y-%m-%d)" \
              --body "## Automated Evidence Run
          
          **Branch:** \`$BRANCH\`
          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          
          ### Contents
          - Evidence run artifacts in \`reports/path1/evidence/runs/\`
          - Updated \`INDEX.md\` (canonical execution ledger)
          - Generated \`RUN_QUEUE_RESOLVED.csv\` (queue reconciliation view)
          
          ### Merge Strategy
          This PR uses **merge commit** (not squash/rebase) to preserve evidence run history.
          
          ---
          *Auto-generated by Path 1 Evidence Queue Runner*")
            
            PR_NUMBER=$(echo "$PR_URL" | grep -oE '[0-9]+$')
            echo "Created PR #$PR_NUMBER: $PR_URL"
          fi
          
          # Enable auto-merge with merge commit strategy
          echo "Enabling auto-merge (merge commit strategy)..."
          gh pr merge "$PR_URL" --auto --merge
          
          echo ""
          echo "=========================================="
          echo "PR #$PR_NUMBER created and auto-merge enabled"
          echo "URL: $PR_URL"
          echo "PR will merge automatically when checks pass."
          echo "Merge strategy: merge commit (preserves history)"
          echo "=========================================="

      - name: Summary
        run: |
          echo "## Path 1 Evidence Queue Run Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Parameter | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|-----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Queue | \`${{ inputs.queue_path }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Max Runs | ${{ inputs.max_runs }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID Filter | ${{ inputs.run_id || '(all)' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Dry Run | ${{ inputs.dry_run }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit Results | ${{ inputs.commit_results }} |" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.commit_results }}" = "true" ] && [ "${{ inputs.dry_run }}" != "true" ]; then
            echo "| Results Branch | \`${{ steps.branch.outputs.branch }}\` |" >> $GITHUB_STEP_SUMMARY
            if [ "${{ steps.commit.outputs.has_changes }}" = "true" ]; then
              echo "| PR Created | ✅ Yes (auto-merge enabled) |" >> $GITHUB_STEP_SUMMARY
            else
              echo "| PR Created | ⏭️ Skipped (no changes) |" >> $GITHUB_STEP_SUMMARY
            fi
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### What Happened" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            echo "This was a **dry run**. No changes were made." >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.commit_results }}" = "true" ]; then
            if [ "${{ steps.commit.outputs.has_changes }}" = "true" ]; then
              echo "1. ✅ Evidence artifacts generated and committed to branch \`${{ steps.branch.outputs.branch }}\`" >> $GITHUB_STEP_SUMMARY
              echo "2. ✅ \`RUN_QUEUE_RESOLVED.csv\` generated (queue → ledger reconciliation)" >> $GITHUB_STEP_SUMMARY
              echo "3. ✅ Pull Request created with **auto-merge enabled** (merge commit strategy)" >> $GITHUB_STEP_SUMMARY
              echo "4. ⏳ PR will merge automatically when required checks pass" >> $GITHUB_STEP_SUMMARY
            else
              echo "**NOOP**: No new runs executed. Queue may be empty or all runs already complete." >> $GITHUB_STEP_SUMMARY
              echo "" >> $GITHUB_STEP_SUMMARY
              echo "Check \`INDEX.md\` to see completed runs." >> $GITHUB_STEP_SUMMARY
            fi
          else
            echo "Artifacts uploaded but not committed to a branch." >> $GITHUB_STEP_SUMMARY
            echo "Download from workflow artifacts." >> $GITHUB_STEP_SUMMARY
          fi
