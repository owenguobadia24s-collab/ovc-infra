name: Path 1 Evidence Queue Runner

on:
  workflow_dispatch:
    inputs:
      queue_path:
        description: 'Path to queue CSV file (relative to repo root)'
        required: false
        default: 'reports/path1/evidence/RUN_QUEUE.csv'
        type: string
      max_runs:
        description: 'Maximum runs to execute'
        required: false
        default: '10'
        type: string
      run_id:
        description: 'Execute only this specific run_id (leave empty for all queued)'
        required: false
        default: ''
        type: string
      commit_results:
        description: 'Commit results to new branch'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'
      branch_name:
        description: 'Branch name for results (auto-generated if empty)'
        required: false
        default: ''
        type: string
      dry_run:
        description: 'Dry run (validate only, no execution)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'false'
          - 'true'

# Required permissions for pushing branches and creating PRs
permissions:
  contents: write
  pull-requests: write

# Task C remediation: Serialize workflow runs to prevent queue race conditions
# cancel-in-progress: false ensures queue integrity (queued runs wait rather than cancel)
concurrency:
  group: path1-evidence-queue
  cancel-in-progress: false

jobs:
  run-evidence-queue:
    runs-on: ubuntu-latest
    timeout-minutes: 30

    env:
      DATABASE_URL: ${{ secrets.DATABASE_URL }}
      NEON_DSN: ${{ secrets.NEON_DSN }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Validate inputs
        run: |
          echo "Queue path: ${{ inputs.queue_path }}"
          echo "Max runs: ${{ inputs.max_runs }}"
          echo "Run ID filter: ${{ inputs.run_id || '(all)' }}"
          echo "Commit results: ${{ inputs.commit_results }}"
          echo "Dry run: ${{ inputs.dry_run }}"
          
          # Validate queue file exists
          if [ ! -f "${{ inputs.queue_path }}" ]; then
            echo "ERROR: Queue file not found: ${{ inputs.queue_path }}"
            exit 1
          fi
          
          # Count non-empty, non-comment lines
          QUEUE_COUNT=$(grep -v '^#' "${{ inputs.queue_path }}" | grep -v '^run_id' | grep -v '^$' | wc -l)
          echo "Runs in queue: $QUEUE_COUNT"
          
          if [ "$QUEUE_COUNT" -eq 0 ]; then
            echo "WARNING: Queue is empty"
          fi

      - name: Validate required secrets
        run: |
          python3 - << 'PY'
          import os, sys
          
          db_url = os.environ.get("DATABASE_URL") or os.environ.get("NEON_DSN")
          if not db_url:
              print("ERROR: DATABASE_URL or NEON_DSN secret not configured")
              sys.exit(1)
          
          # Mask the secret
          print("Database secret: configured ✓")
          PY

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install PostgreSQL client
        run: |
          sudo apt-get update
          sudo apt-get install -y postgresql-client
          psql --version

      - name: Determine branch name
        id: branch
        run: |
          if [ -n "${{ inputs.branch_name }}" ]; then
            BRANCH="${{ inputs.branch_name }}"
          else
            TIMESTAMP=$(date -u +%Y%m%d-%H%M%S)
            BRANCH="evidence-run-${TIMESTAMP}"
          fi
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "Branch for results: $BRANCH"

      - name: Execute evidence queue runner
        id: runner
        run: |
          # Build command
          CMD="python scripts/path1/run_evidence_queue.py"
          CMD="$CMD --queue '${{ inputs.queue_path }}'"
          CMD="$CMD --max-runs ${{ inputs.max_runs }}"
          CMD="$CMD --repo-root ."
          
          if [ -n "${{ inputs.run_id }}" ]; then
            CMD="$CMD --run-id '${{ inputs.run_id }}'"
          fi
          
          if [ "${{ inputs.dry_run }}" = "true" ]; then
            CMD="$CMD --dry-run"
          fi
          
          echo "Executing: $CMD"
          eval $CMD | tee /tmp/runner_output.txt
          
          # Extract executed run_ids from output for validation step
          # Format: "✅ PASS | run_id | message" or "❌ FAIL | run_id | message"
          EXECUTED_RUNS=$(grep -E '^\s*(✅|❌)' /tmp/runner_output.txt | awk -F'|' '{print $2}' | tr -d ' ' | tr '\n' ',' | sed 's/,$//')
          echo "executed_runs=$EXECUTED_RUNS" >> $GITHUB_OUTPUT
          echo "Executed run IDs: $EXECUTED_RUNS"

      - name: Read Path1 summary JSON
        id: path1_summary
        run: |
          python3 - << 'PY'
          import json
          import os
          from pathlib import Path
          
          summary_path = Path("artifacts/path1_summary.json")
          if not summary_path.exists():
              raise SystemExit(f"Missing summary JSON: {summary_path}")
          
          data = json.loads(summary_path.read_text(encoding="utf-8"))
          output_path = os.environ["GITHUB_OUTPUT"]
          with open(output_path, "a", encoding="utf-8") as f:
              for key in ("run_id", "date_from", "date_to", "rows_processed", "outcome"):
                  value = "" if data.get(key) is None else str(data.get(key))
                  f.write(f"{key}={value}\n")
          PY

      # NOTE:
      # Evidence artifacts are written directly to:
      #   reports/path1/evidence/runs/<run_id>/
      # following the canonical pattern established in Runs 001–003.
      # No post-processing, relocation, or archiving occurs here.

      - name: Validate Evidence Run (Post-Run Gate)
        if: inputs.dry_run != 'true'
        run: |
          echo "=== Post-Run Validation ==="
          
          # FUTURE (NOT IMPLEMENTED):
          # A queue archival / status protocol may be added later.
          # This workflow intentionally does NOT:
          # - mark queue rows as complete
          # - move completed runs
          # - archive run folders
          # The queue remains intent-only; INDEX.md is the execution ledger.
          
          # Determine which run_ids to validate
          if [ -n "${{ inputs.run_id }}" ]; then
            # Canonical pattern: specific run_id was requested
            RUNS_TO_VALIDATE="${{ inputs.run_id }}"
          else
            # Extract from runner output
            RUNS_TO_VALIDATE="${{ steps.runner.outputs.executed_runs }}"
          fi
          
          if [ -z "$RUNS_TO_VALIDATE" ]; then
            echo "No runs executed (NOOP case). Skipping validation."
            exit 0
          fi
          
          echo "Run IDs to validate: $RUNS_TO_VALIDATE"
          
          # Validate each executed run
          VALIDATION_FAILED=0
          IFS=',' read -ra RUN_ARRAY <<< "$RUNS_TO_VALIDATE"
          for RUN_ID in "${RUN_ARRAY[@]}"; do
            if [ -z "$RUN_ID" ]; then
              continue
            fi
            
            echo ""
            echo "--- Validating: $RUN_ID ---"
            
            if ! python scripts/path1/validate_post_run.py --run-id "$RUN_ID" --repo-root .; then
              echo "❌ VALIDATION FAILED: $RUN_ID"
              VALIDATION_FAILED=1
            else
              echo "✅ VALIDATION PASSED: $RUN_ID"
            fi
          done
          
          if [ "$VALIDATION_FAILED" -eq 1 ]; then
            echo ""
            echo "=========================================="
            echo "POST-RUN VALIDATION FAILED"
            echo "One or more runs did not pass integrity checks."
            echo "Review violations above. Workflow will not proceed."
            echo "=========================================="
            exit 1
          fi
          
          echo ""
          echo "✅ All evidence runs passed validation"

      - name: List generated artifacts
        if: inputs.dry_run != 'true'
        run: |
          echo "=== SQL Files Generated ==="
          find sql/path1/evidence/runs -name "*.sql" -type f 2>/dev/null | head -50 || echo "No SQL files"
          
          echo ""
          echo "=== Report Files Generated ==="
          find reports/path1/evidence/runs -name "*.md" -type f 2>/dev/null | head -50 || echo "No report files"
          
          echo ""
          echo "=== Output Files Generated ==="
          find reports/path1/evidence/runs -name "*.txt" -type f 2>/dev/null | head -50 || echo "No output files"

      # Task B remediation: Verify artifacts exist before upload
      - name: Verify artifacts exist
        if: inputs.dry_run != 'true'
        run: |
          echo "=== Artifact Verification (Task B) ==="
          
          # Count files in each artifact path
          SQL_COUNT=$(find sql/path1/evidence/runs -type f 2>/dev/null | wc -l)
          REPORT_COUNT=$(find reports/path1/evidence/runs -type f 2>/dev/null | wc -l)
          
          echo "SQL files found: $SQL_COUNT"
          echo "Report files found: $REPORT_COUNT"
          
          TOTAL=$((SQL_COUNT + REPORT_COUNT))
          echo "Total artifact files: $TOTAL"
          
          if [ "$TOTAL" -eq 0 ]; then
            echo ""
            echo "ERROR: No artifact files found!"
            echo "Expected files in:"
            echo "  - sql/path1/evidence/runs/"
            echo "  - reports/path1/evidence/runs/"
            echo ""
            echo "This indicates the evidence run did not generate expected outputs."
            echo "Check the execution logs above for errors."
            exit 1
          fi
          
          echo ""
          echo "✅ Artifact verification passed ($TOTAL files found)"

      - name: Upload artifacts
        if: inputs.dry_run != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: evidence-run-artifacts-${{ github.run_number }}
          path: |
            sql/path1/evidence/runs/
            reports/path1/evidence/runs/
            reports/path1/evidence/INDEX.md
          retention-days: 90
          # Task B remediation: Fail if no files match (explicit over default 'warn')
          if-no-files-found: error

      - name: Configure Git
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create branch and commit results
        id: commit
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true'
        run: |
          BRANCH="${{ steps.branch.outputs.branch }}"
          
          # Create new branch
          git checkout -b "$BRANCH"
          
          # Generate RUN_QUEUE_RESOLVED.csv (reconciles queue intent with INDEX.md ledger)
          echo "Generating RUN_QUEUE_RESOLVED.csv..."
          python scripts/path1/generate_queue_resolved.py --repo-root .
          
          # Stage generated files
          # IMPORTANT: RUN_QUEUE.csv is intentionally NOT committed.
          # Queue status updates are LOCAL ONLY and will be lost after workflow.
          # INDEX.md is the canonical execution ledger, not the queue.
          # RUN_QUEUE_RESOLVED.csv is a generated reconciliation view.
          git add sql/path1/evidence/runs/
          git add reports/path1/evidence/runs/
          git add reports/path1/evidence/INDEX.md
          git add reports/path1/evidence/RUN_QUEUE_RESOLVED.csv
          
          # Check if there are changes to commit
          if git diff --cached --quiet; then
            echo "No changes to commit (NOOP)"
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "commit_sha=" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_changes=true" >> $GITHUB_OUTPUT
          
          # Commit
          git commit -m "Path 1 Evidence Run(s) - Automated
          
          Queue: ${{ inputs.queue_path }}
          Max runs: ${{ inputs.max_runs }}
          Run ID filter: ${{ inputs.run_id || '(all)' }}
          
          Generated by: .github/workflows/path1_evidence_queue.yml
          Workflow run: ${{ github.run_id }}"
          
          echo "commit_sha=$(git rev-parse HEAD)" >> $GITHUB_OUTPUT
          
          # Push branch
          git push origin "$BRANCH"
          
          echo ""
          echo "=========================================="
          echo "Results committed to branch: $BRANCH"
          echo "=========================================="

      - name: Create Pull Request and enable auto-merge
        if: inputs.commit_results == 'true' && inputs.dry_run != 'true' && steps.commit.outputs.has_changes == 'true'
        env:
          # Use PAT for PR creation to enable auto-merge and trigger downstream workflows
          # GITHUB_TOKEN cannot trigger workflows or enable auto-merge on PRs it creates
          # Set both to remove any ambiguity in gh CLI auth resolution
          GH_TOKEN: ${{ secrets.OVC_PR_BOT_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.OVC_PR_BOT_TOKEN }}
        run: |
          # Validate PAT secret is configured
          if [ -z "${GH_TOKEN:-}" ]; then
            echo "=========================================="
            echo "ERROR: OVC_PR_BOT_TOKEN secret is not configured"
            echo "=========================================="
            echo ""
            echo "This workflow requires a Personal Access Token (PAT) to create PRs"
            echo "and enable auto-merge."
            echo ""
            echo "To fix: Create repo secret OVC_PR_BOT_TOKEN"
            echo "   Settings → Secrets and variables → Actions → New repository secret"
            echo ""
            exit 1
          fi

          # ---------------------------------------------------------------------------
          # Diagnostics: verify token can authenticate and access this repo
          # (Does NOT print secrets; only safe excerpts)
          # ---------------------------------------------------------------------------
          echo "=== GH CLI Auth Diagnostics ==="
          echo ""

          # gh auth status (safe excerpt - never prints token)
          echo "--- gh auth status ---"
          gh auth status 2>&1 | grep -E '^(  ✓|  -)' || echo "(no status lines)"
          echo ""

          AUTH_OK=true

          # Authenticated username via REST API
          echo "--- Authenticated user ---"
          AUTH_USER=$(gh api user --jq '.login' 2>/dev/null || echo "")
          if [ -z "$AUTH_USER" ]; then
            echo "ERROR: gh api user failed - cannot determine authenticated user"
            AUTH_OK=false
          else
            echo "Authenticated as: $AUTH_USER"
          fi
          echo ""

          # Repo access check via REST API
          echo "--- Repo access ---"
          REPO_CHECK=$(gh api "repos/${GITHUB_REPOSITORY}" --jq '.full_name' 2>/dev/null || echo "")
          if [ -z "$REPO_CHECK" ]; then
            echo "ERROR: gh api repos/${GITHUB_REPOSITORY} failed - cannot access repo"
            AUTH_OK=false
          else
            echo "Repo access confirmed: $REPO_CHECK"
          fi
          echo ""

          if [ "$AUTH_OK" = "false" ]; then
            echo "=========================================="
            echo "ERROR: OVC_PR_BOT_TOKEN cannot authenticate or cannot access this repo."
            echo "=========================================="
            echo "Regenerate token with repo access to ovc-infra and permissions:"
            echo "  - Pull requests: Read and Write"
            echo "  - Contents: Read and Write"
            echo "=========================================="
            exit 1
          fi

          echo "=== Auth diagnostics passed ==="
          echo ""

          BRANCH="${{ steps.branch.outputs.branch }}"
          # Derive OWNER from GITHUB_REPOSITORY (format: owner/repo)
          OWNER="${GITHUB_REPOSITORY%%/*}"

          # ---------------------------------------------------------------------------
          # Check if PR already exists for this branch using REST API
          # Uses: GET /repos/{owner}/{repo}/pulls?head={owner}:{branch}&state=open
          # This avoids GraphQL which fails with "Resource not accessible by personal access token"
          # ---------------------------------------------------------------------------
          echo "Checking for existing PR via REST API..."
          EXISTING_PR_JSON=$(gh api "repos/${GITHUB_REPOSITORY}/pulls?head=${OWNER}:${BRANCH}&state=open" 2>/dev/null || echo "[]")

          # Parse first PR from response (empty array = no PR exists)
          PR_NUMBER=$(echo "$EXISTING_PR_JSON" | jq -r '.[0].number // empty')
          PR_URL=$(echo "$EXISTING_PR_JSON" | jq -r '.[0].html_url // empty')

          if [ -n "$PR_NUMBER" ] && [ "$PR_NUMBER" != "null" ]; then
            echo "PR #$PR_NUMBER already exists for branch $BRANCH"
            echo "URL: $PR_URL"
          else
            # ---------------------------------------------------------------------------
            # Create PR using REST API
            # Uses: POST /repos/{owner}/{repo}/pulls
            # ---------------------------------------------------------------------------
            echo "Creating Pull Request via REST API..."

            PR_TITLE="Path 1 Evidence Run(s) - $(date -u +%Y-%m-%d)"
            PR_BODY=$(cat <<'PRBODY'
          ## Automated Evidence Run

          **Workflow Run:** [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

          ### Contents
          - Evidence run artifacts in `reports/path1/evidence/runs/`
          - Updated `INDEX.md` (canonical execution ledger)
          - Generated `RUN_QUEUE_RESOLVED.csv` (queue reconciliation view)

          ### Merge Strategy
          This PR uses **merge commit** (not squash/rebase) to preserve evidence run history.

          ---
          *Auto-generated by Path 1 Evidence Queue Runner*
          PRBODY
          )

            PR_RESPONSE=$(gh api "repos/${GITHUB_REPOSITORY}/pulls" \
              --method POST \
              --field title="$PR_TITLE" \
              --field head="${BRANCH}" \
              --field base="main" \
              --field body="$PR_BODY" 2>&1) || {
              echo "ERROR: Failed to create PR via REST API"
              echo "$PR_RESPONSE"
              exit 1
            }

            PR_NUMBER=$(echo "$PR_RESPONSE" | jq -r '.number')
            PR_URL=$(echo "$PR_RESPONSE" | jq -r '.html_url')

            if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
              echo "ERROR: PR creation response missing PR number"
              echo "Response: $PR_RESPONSE"
              exit 1
            fi

            echo "Created PR #$PR_NUMBER: $PR_URL"
          fi

          # ---------------------------------------------------------------------------
          # Enable auto-merge with merge commit strategy (NON-FATAL)
          # PR creation is a ledger write and MUST succeed even if repo governance
          # (branch protection / required checks) isn't configured yet.
          # ---------------------------------------------------------------------------
          echo ""
          echo "Attempting to enable auto-merge (merge commit strategy)..."
          MERGE_STATUS=""

          # Use if/else pattern to ensure auto-merge failure does not fail the workflow
          if gh pr merge "$PR_URL" --auto --merge 2>&1; then
            echo "Auto-merge enabled."
            MERGE_STATUS="auto-merge enabled"
          else
            echo ""
            echo "WARN: Auto-merge could not be enabled (likely missing branch protection / required checks)."
            echo "PR remains open: $PR_URL"
            MERGE_STATUS="auto-merge not enabled (see logs)"
            # Continue with exit 0 - PR creation succeeded, that's what matters
          fi

          echo ""
          echo "=========================================="
          echo "PR #$PR_NUMBER created"
          echo "URL: $PR_URL"
          echo "Merge status: $MERGE_STATUS"
          echo "Merge strategy: merge commit (preserves history)"
          echo "=========================================="

      - name: Summary
        run: |
          echo "## Path 1 Evidence Run Summary (Non-Canonical)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Field | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID | \`${{ steps.path1_summary.outputs.run_id }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Date range | \`${{ steps.path1_summary.outputs.date_from }} to ${{ steps.path1_summary.outputs.date_to }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Rows processed | ${{ steps.path1_summary.outputs.rows_processed }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Outcome | ${{ steps.path1_summary.outputs.outcome }} |" >> $GITHUB_STEP_SUMMARY
          
          COMMIT_SHA="N/A"
          if [ "${{ steps.commit.outputs.has_changes }}" = "true" ] && [ -n "${{ steps.commit.outputs.commit_sha }}" ]; then
            COMMIT_SHA="${{ steps.commit.outputs.commit_sha }}"
          fi
          echo "| Commit | \`${COMMIT_SHA}\` |" >> $GITHUB_STEP_SUMMARY
